{% extends "base.html" %}
{% block content %}
<div class="module">
        <h1>
            The DevOps Way of Work
        </h1>

        <figure>
            <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6c/Labor-Pearce-Highsmith-detail-1.jpeg/440px-Labor-Pearce-Highsmith-detail-1.jpeg"
            width="21%">
            <figcaption>
            </figcaption>
        </figure>

        <p class="leadquote">
            "Working software is the primary measure of progress." -- The Agile
            Manifesto
        </p>

        <figure>
            <iframe width="560" height="315"
                src="https://www.youtube.com/embed/QayYJouXzSk"
                frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>
            </iframe>
            <figcaption>
                Lecture 1: What is DevOps?
            </figcaption>
        </figure>

        <details>
            <summary class="sum1">
                Lesson 1: DevOps as Software Engineering
            </summary>

            <p>
                As software engineers, our aim should be to deliver programs to
                our users that perform the tasks they need that sotware to
                perform. The whole field of software engineering has centered
                around how to achieve that goal.
            </p>

            <p>
                One attempt to achieve it was the
                <a href="https://en.wikipedia.org/wiki/Waterfall_model">
                    waterfall model</a>
                of software developement.
            </p>

            <figure>
                <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e2/Waterfall_model.svg/700px-Waterfall_model.svg.png"
                width="24%">
                <figcaption>
                    The waterfall model
                </figcaption>
            </figure>

            <p>
                But the waterfall model produced many failures:
                <a href="https://en.wikipedia.org/wiki/Death_march_(project_management)">death marches</a>,
                instances of the 
                <a href="https://en.wikipedia.org/wiki/Ninety-ninety_rule">ninety-ninety rule</a>,
                <a
                    href="https://en.wikipedia.org/wiki/Small_matter_of_programming">small
                    matter of programming issues</a>,
                <a
                    href="https://en.wikipedia.org/wiki/Planning_fallacy">planning
                    fallacies</a>,
                and many more such problems. And we can offer a sound diagnosis
                of <i>why</i> so many waterfall projects failed: the model
                assumed that all knowledge about a project could be captured by
                a small group of expert "analysts" right at the start of the
                project, and the job of the rest of the people involved
                was just to follow the instructions of those experts, and not
                to think for themselves. In short, the waterfall model was
                a species of
                <a
                    href="https://en.wikipedia.org/wiki/Scientific_management">Taylorism</a>.
            </p>

            <p>
                Of course, <i>some</i> software projects using the waterfall
                model succeeded. But it turns out that most successful software
                projects, over many decades, instead followed the 
                "<a href="https://en.wikipedia.org/wiki/Unix_philosophy">UNIX
                    philosophy</a>", 
                where development projects sought to quickly achieve an
                <a
                    href="https://en.wikipedia.org/wiki/Minimum_viable_product">MVP</a>,
                and then proceeded to improve that initial product with
                incremental changes.
            </p>

            <p>
                The recognition of this fact lead, over time, to the
                formulation of the
                <a href="https://en.wikipedia.org/wiki/Lean_software_development">Lean</a>
                and 
                <a href="https://en.wikipedia.org/wiki/Agile_software_development">Agile</a>
                development methods. These methods focused on rapidly creating
                and releasing to users incremental improvements in a software.
                (Please take the time to read the <i>Wikipedia</i> pages linked
                to above on Lean and Agile: you are responsible for knowing
                that material.)
                The advantages of small improvements to a software product,
                released frequently, include:
            </p>

            <ul class="nested">
                <li>
                    Value is delivered to the users quickly, rather than
                    waiting for "release 2.0" for the users to get a hold of
                    the features they need.
                </li>

                <li>
                    Small batches can more easily be tested and verified as
                    working properly.
                </li>

                <li>
                    If a small release contains an error, it is easier to roll
                    it back than it is to roll back a major release.
                </li>

                <li>
                    The "feedback loop" between users and programmers 
                    is shortened, allowing programmers to  learn about
                    users' needs more rapidly, and respond more quickly
                    to them.
                </li>

                <li>
                    Greater programmer satisfaction, as programmers can
                    regularly see the value of their work to their users.
                </li>

            </ul>

            <p>
                As development teams adopted Lean and Agile methods, they often 
                became capable of producing production-ready software on a
                daily basis, or even more frequently. (For instance, Amazon
                releases software into production once every 11 seconds, on
                average.) But this created a problem: managing software in
                production environments was traditionally the job of 
                <i>operations</i>, not of the developers. And operations viewed
                its job as <i>slowing</i> the pace of releases, because
                releases meant bugs, crashes, and other problems operations had
                to handle.
            </p>

            <p>
                How could this gulf between development and operations be narrowed?
                A few forward-thinking operations people saw a way to reconcile 
                the aims of development and operations: operations itself had
                to become Lean and Agile! In particular, rather than 
                hand-provisioning operations infrastructure, operations team
                members had to themselves become coders, and apply the full
                toolkit of Lean and Agile methods to operations: incremental
                changes, automated testing, source code control, automated
                builds, and so on.
                One of those operations people,
                Patrick Debois, named a conference
                <a href="https://en.wikipedia.org/wiki/DevOps#Definitions_and_history">
                    DevOpsDays</a>, and from that seed, the term "DevOps"
                spread.
            </p>

            <p>
                As a result, the term "DevOps" is an umbrella beneath which 
                reside a large number of methods and tools. We can better
                undertand why each of the areas we will studying falls under
                "DevOps" when we comprehend how they contribute to the DevOps
                goal of delivering useful and correct software to users as
                rapidly and as often as possible. Let's look at how the main
                areas of DevOps contribute to this goal:
            </p>

            <ul class="nested">
               <li>
                    Testers cannot test successfully
                    unless they are part of the
                    production process from day one: thus, <i>continuous
                        testing</i>.
                </li>

                <li>
                     Operations cannot successfully deploy constantly evolving
                     products unless deployment itself becomes a software
                     product capable of swiftly evolving:
                     thus, <i>software as infrastructure</i>.
                </li>

                <li>
                    The "business" stakeholders in the product can't ensure
                    it is meeting business needs unless they
                    are continually engaged: thus
                    <i>continual interaction</i> between the engineers and the
                    "business people."
                </li>

                <li>
                    Why is "business" in scare quotes above?
                    <br />
                    "We are not developing software. We are doing something
                    larger and software is just part of the solution." -- Tom
                    Poppendieck
                </li>
                <li>
                    How new versions of a piece of software impact the end
                    users cannot be determined without <i>continual feedback</i>
                    from those users, thus:
                </li>
                <li>
                    <i>Incremental development</i>, which means
                    developers work on small batches and can easily change
                    course based on feedback;
                </li>
                <li>
                    <i>Continuous deployment</i>, allowing users to
                    comment on the work done in those small batches;
                    and
                </li>

                <li>
                    <i>Continuous monitoring</i>, so that problems using the
                    product become known right away.
                </li>

            </ul>

            <p>
                At this point in our course, you should read the
                <i>Wikipedia</i> page on
                <a href="https://en.wikipedia.org/wiki/DevOps">DevOps</a>.
            </p>

        </details>

        <details>
            <summary class="sum1">
                Lesson 2: My DevOps Story
            </summary>

            <p class="leadquote">
                Or how, being weaned on nutritious Bell Labs commonsense,
                and having dined on Oakeshott's critique of rationalism,
                I was ready to digest the DevOps feast.
            </p>

            <p>
                I began my career as a software engineer
                working on MS-DOS computers in the mid-1980s.
                But before the decade was over, I had begun
                working on UNIX platforms. As I came to appreciate
                the elegance of the UNIX programming environment,
                I sought out the writings of the people who had been
                instrumental in its creation. This was the tremendous
                group of software engineers assembled in Bell Labs
                from the late 1960s through the early 1980s, including
                Ken Thompson, Dennis Ritchie, Brian Kernighan,
                Alfred Aho, Peter Weinberger, Bjarne Stroustrup,
                Jon Bentley, and P.J. Plauger. From them I learned a
                pragmatic, incremental style of developing software.
                Rather than pursuing some grand, abstract vision,
                I learned to deliver minimal but working software to users
                as regularly as possible, and to learn from
                user feedback what further features needed to
                be added.
            </p>

            <figure>
                <img
                src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Unix_history-simple.svg/300px-Unix_history-simple.svg.png">
                <figcaption>
                    UNIX and its discontents
                </figcaption>
            </figure>

            <p>
                By the 1990s, I had learned enough that I felt ready to
                make my own contributions to this literature, writing
                <a
                    href="http://dunne.yenn.ulegend.net/semiotics-and-gui-design.html">
                    on the benefits of symbolic interfaces</a>,
                <a href="https://dl.acm.org/citation.cfm?id=249758">
                    pioneering intranets as a way of delivering in-house
                    software</a>,
                <a href="">touting infrastructure as code</a>,
                <a href="http://genecallahan.ulitzer.com/node/36326">
                    describing generic client-server interfaces</a>,
                <a href="http://genecallahan.ulitzer.com/node/36519">
                    stressing the basics of OOP</a>, and more.
            </p>

            <p>
                Subsequently, in a decade away from software engineering, I
                conducted extensive studies on
                <a href="https://gcallah.github.io/Rationalism/index.html">
                    rationalism</a>. These studies prepared me to understand
                development methods like the waterfall model as examples of
                "dreaming of systems so perfect that no one will need to be good"*
                -- these practitioners were practicing
                "rationalism in software engineering."
                Or, to put it in my colleague Nassim Taleb's terms, these
                systems were designed to be robust, impervious to change.
                (Consider the desire to "lock down" the software's feature
                set in the requirements phase of the waterfall model.)
                What was needed instead were systems that were
                <a
                   href="https://en.wikipedia.org/wiki/Antifragility">antifragile</a>,
                and actually thrived on change.
            </p>

            <figure>
                <iframe width="560" height="315"
                   src="https://www.youtube.com/embed/k4MhC5tcEv0" frameborder="0"
                   allowfullscreen>
                </iframe>
                <figcaption>
                    Nassim Taleb talks antifragility
                </figcaption>
            </figure>

            <p>
                Thus, when I returned to software engineering
                and came across the DevOps movement, my experience was
                not one of meeting someone brand new, but of re-acquainting
                myself with an old friend who was sporting a new look,
                and had learned some fancy new tricks since we had last met.
                In particular, the DevOps approach does not try to ensure
                design is 100% complete before any code is written: an impossible,
                rationalist dream. The DevOps approach
                does not attempt to ensure all software
                leaving a developer's hands is bug-free: again, an impossible,
                rationalist dream. And it does not attempt to ensure that
                all released software is 100% crash-free and secure. Instead,
                the DevOps approach recognizes that humans are fallible and
                errors will occur, and so stresses <i>fast recovery from
                errors</i> and a <i>low-blame culture</i>
                that emphasizes learning from
                errors rather than punishing transgressors. So, for instance,
                rather than blaming the programmer who released a piece
                of buggy code into production, the DevOps approach asks,
                "What test haven't we written that would have caught that
                bug before release?"
            </p>

            <hr>

            <p>
                * T.S. Eliot, "Choruses from the Rock"
            </p>
        </details>

        <details>
            <summary class="sum1">
                Lesson 3: DevOps and the Division of Labor
            </summary>

            <p>
            Leonard E. Read began his
            famous essay “I, Pencil” (<a
            href="http://www.econlib.org/library/Essays/rdPncl1.html">here</a>)
            by noting:
            </p>
            
            <blockquote>
            I, Pencil, simple though I appear to be, merit your
            wonder and awe, a claim I shall attempt to prove… Simple? Yet, not a single
            person on the face of this earth knows how to make me. This sounds fantastic,
            doesn't it? Especially when it is realized that there are about one and
            one-half billion of my kind produced in the U.S.A. each year.
            </blockquote>
            
            <p>
            Read goes on to list just a few of the many, many people who
            contribute to the making of a “simple” pencil: loggers, miners,
            makers of chain saws, hemp growers, the manufacturers of railroads
            and railroad cars, millworkers, producers of precision
            assembly-line machines, the harvesters of canola seed, farmers
            growing castor beans, and more.
            </p>
            
            <p>
            What Read is praising in his essay are the benefits of the division
            of labor, the economic process through which a human community, by
            dividing up tasks and “assigning” various members to specialize in
            each task, can greatly increase its output. (I put “assigning” in
            scare quotes because, in a market economy, for the most part people
            are not literally <i>assigned</i> to tasks, but instead choose
            their roles in the division of labor based upon their talents and
            the prevailing compensation for each possible role they could
            fill.) The benefits of the division of labor were, of course,
            recognized at least as far back as Plato and Xenophon. As Plato put
            it in <i>The Republic</i>, “Well then, how will our state supply
            these (physical) needs? It will need a farmer, a builder, and a
            weaver, and also, I think, a shoemaker and one or two others to
            provide for our bodily needs. So that the minimum state would
            consist of four or five men.” And Adam Smith famously expounded
            upon those benefits in <i>The Wealth of Nations</i>, writing “The
            greatest improvement in the productive powers of labour, and the
            greater part of the skill, dexterity, and judgment with which it is
            anywhere directed, or applied, seem to have been the effects of the
            division of labour” (<a
            href="http://www.econlib.org/library/Smith/smWN1.html#B.I,%20Ch.1,%20Of%20the%20Division%20of%20Labor"><i>The
                Wealth of Nations</i></a>).
            Smith goes on to describe the production of pins, a task at which a
            single person, not specialized at the task, “could scarce, perhaps,
            with his utmost industry, make one pin in a day, and certainly could
            not make twenty” (same source as above). But, when ten workers took on
            specialized tasks, with the help of specialized machinery, though “they
            were very poor, and therefore but indifferently accommodated with the
            necessary machinery, they could, when they exerted themselves, make
            among them about twelve pounds of pins in a day” (same source), with
            the result that each worker produced several thousand times the number
            of pins per day as would have been possible without the division of
            labor.
            </p>
            
            <p>
            In the early 20th century, this method of increasing productivity
            was pushed to its limits. Tasks were broken down to the extent that
            workers with minimal skills could be assigned simple, highly
            repetitive actions, and perform them with almost no knowledge of
            what anyone else on the assembly line was up to. Although this led
            to higher output of standardized products, the disadvantages of
            extending the division of labor to this extent were not overlooked.
            Karl Marx noted that the extensive division of labor alienated the
            worker from the product he was producing: someone who spends all
            day tightening a particular lug nut may be little able to associate
            what they do with “making a car.” But even Adam Smith, who, as we
            have seen, praised the effects of the division of labor, commented:
            </p>
            
            <blockquote>
            
            In the progress of the division of labour, the employment of the
            far greater part of those who live by labour, that is, of the great
            body of people, comes to be confined to a few very simple
            operations, frequently to one or two. But the understandings of the
            greater part of men are necessarily formed by their ordinary
            employments. The man whose whole life is spent in performing a few
            simple operations, of which the effects are perhaps always the
            same, or very nearly the same, has no occasion to exert his
            understanding or to exercise his invention in finding out
            expedients for removing difficulties which never occur. He
            naturally loses, therefore, the habit of such exertion, and
            generally becomes as stupid and ignorant as it is possible to
            become for a human creature to become. (<a
            href="http://www.econlib.org/library/Smith/smWN20.html#V.1.178">http://www.econlib.org/library/Smith/smWN20.html#V.1.178</a>)
            </blockquote>
            
            <p>
            Smith is pointing out a <i>general</i> problem with the extensive
            division of labor, but there is a much more <i>particular</i>
            problem, which only came to prominence in the recent days of
            increasing automation and increasing demand for innovative and
            customized products: the sort of mindless, production-line division
            of tasks common in mid-20th-century factories created a workforce
            downright <i>discouraged</i> from thinking about how their work fit
            into the production process as a whole, or how alterations in other
            parts they did not directly make might affect their own task. Such
            a holistic view was only supposed to be required of the engineers
            who designed new products or who designed the factory processes
            that would produce those new products. As in a planned, socialist
            economy, all knowledge about the product and the production process
            would be concentrated at the top of a pyramid of work, and those
            below the peak were to just mindlessly follow the orders of those
            knowledge commissars.
            </p>
            
            <p>
            A major problem with this approach is that as products become more
            complicated and the pace of innovation increases, no single mind,
            or even a small group of minds, is capable of grasping all of the
            interconnections between the different parts of those complex
            products, and thus, cannot foresee how an innovation supposedly
            concerning only one part will actually have ripple effects on many
            other apparently separate production tasks. This fact was realized
            quite early at Toyota, and led to the invention of the <a
            href="https://en.wikipedia.org/wiki/Toyota_Production_System">
                Toyota Production System</a>,
            the forerunner of Lean Software Development. As Mary and Tom
            Poppendieck note in <i>Implementing Lean Software Development</i>:
            </p>
            
            <blockquote>
            Toyota’s real innovation is its ability to harness the
            intellect of “ordinary” employees. Successful lean initiatives must be based
            first and foremost on a deep respect for every person in the company,
            especially the “ordinary” people who make the product or pound out the code.
            (pp. 124-125)
            </blockquote>
            
            <p>
            As important as these ideas were in factory production, their
            importance is even greater in the world of software development,
            where production is <i>always</i> production of a novel product:
            otherwise, one would simply buy or rent an existing software
            product, which is almost always a lower cost venture than “rolling
            your own.”
            </p>
            
            <p>
            In such an environment, it is simply not possible to assign
            the “workers” (programmers) a simple, repetitive task, and expect them to
            achieve decent results without at least some understanding of the overall
            product design, as well as an understanding of how their particular “part”
            integrates with the other parts of the product as a whole. In such
            a situation, worker obedience no longer “works.” A manager cannot
            tell a software engineer working on a product of even moderate
            complexity to just follow the manager’s orders: the programmer can
            bring production to a halt simply by asking, “OK, what line of code
            should I write next?”
            </p>
            
            <p>
            But further: no knowledge worker producing an even moderately
            complex product can do his work properly without his understanding
            of his part in the production process evolving in continuous
            interaction with the evolving understanding of all of the other
            knowledge workers producing the product: one such worker gaining a
            better understanding of the nature of her component simply
            <i>must</i> convey that understanding to all other workers upon
            whom the changes in her component have an impact, and that set of
            workers typically encompasses <i>almost everyone</i> working on the
            product. As the Disciplined Agile Framework has it:</p>
            
            <blockquote>
            Enterprise awareness is one of the key principles behind the
            Disciplined Agile (DA) framework. The observation is that DA teams
            work within your organization’s enterprise ecosystem, as do all
            other teams. There are often existing systems currently in
            production and minimally your solution shouldn’t impact them.
            Better yet your solution will hopefully leverage existing
            functionality and data available in production. You will often have
            other teams working in parallel to your team, and you may wish to
            take advantage of a portion of what they’re doing and vice versa.
            Your organization may be working towards business or technical
            visions which your team should contribute to. A governance strategy
            exists which hopefully enhances what your team is doing. (<a
            href="http://www.disciplinedagiledelivery.com/enterpriseawareness/)">http://www.disciplinedagiledelivery.com/enterpriseawareness/)</a>
            </blockquote>
            
            <p>
            The various aspects of Agile / Lean / DevOps production follow from
            recognizing these realities concerning knowledge workers
            cooperating to create innovative products. Programmers cannot do
            their jobs in isolation: thus, the practice of <i>continuous
            integration</i>, which quickly exposes mutual misunderstandings of
            how one person’s work impacts that of others. Testers cannot test
            successfully, without introducing large delays in deployment, unless
            they are part of the production process from day one: thus,
            <i>continuous testing</i>, guaranteeing that product flaws are exposed
            and fixed at the earliest moment possible. Operations cannot
            successfully deploy constantly evolving products unless deployment
            itself becomes a software product capable of evolving as fast as the
            products of the developers: thus, <i>software as infrastructure</i>.
            The “business” stakeholders in the product cannot ensure the product is
            really meeting business needs unless they are continually engaged in
            the development process: thus <i>continual interaction</i> between the
            engineers and the “business people.” How new versions of a piece of
            software impact the end users cannot be determined without continual
            feedback from those users: thus, <i>incremental development</i>, which
            means developer work on small batches and can easily change course;
            <i>continuous deployment</i>, allowing end users to comment on the work
            done in those small batches; and <i>continuous monitoring</i>, so that
            any problems using the product become known almost as soon as they
            occur.
            </p>
            
            <p>
            Given the above realities, a rigid division of labor hinders
            businesses from responding agilely to changing market conditions
            while producing software. If workers are confined to narrow silos
            based on job title, the interaction between the many components of
            a complex piece of software must be defined from the top down, and
            this restriction will result in a very limited capacity to deviate
            from an initially defined pattern of interaction. In Disciplined
            Agile, it is noted:
            </p>
            
            <blockquote>
            IT departments are complex adaptive organizations.  What we mean by
            that is that the actions of one team will affect the actions of
            another team, and so on and so on.  For example, the way that your
            agile delivery team works will have an effect on, and be affected
            by, any other team that you interact with.  If you’re working with
            your operations teams, perhaps as part of your overall DevOps
            strategy, then each of those teams will need to adapt the way they
            work to collaborate effectively with one another.  Each team will
            hopefully learn from the other and improve the way that they work.
            (<a
            href="http://www.disciplinedagiledelivery.com/agility-at-scale/disciplined-agile-2/">Disciplined Agile</a>)
            </blockquote>
            
            <p>
            Let us consider a realistic
            change that might hit a project mid-stream, and just a few of the areas it
            might impact.
            </p>
            
            <p>
            I was once developing an option-trading package for a team of
            traders. At first, we were only getting quotes for options from a
            single exchange. The traders realized that they wanted instead to
            see the best bid and ask from every exchange, which meant we needed
            to get quotes from four exchanges, not one. This might seem to be a
            specification change with a narrow scope: just add three more price
            feeds to the application. Who would this concern beyond the
            programmer who would be adding the feature?</p> <p> Well, for one,
            it would concern the team supporting the price server: this was
            going to quadruple the load this application would place on it. It
            was also going to impact the order server: that server had to be
            prepared to send orders out to the proper exchanges. Oh, and the
            testing team had better be prepared to simulate quotes coming in
            from four sources, not one.  Also, the monitoring team would have
            to detect if there was a lag on quotes arriving from four sources,
            not one.
            </p>
            
            <p>
            Or consider the patterns and tales from Michael T. Nygard’s book,
            <i>Release It!</i>. Continually, in Nygard’s stories, solving a
            problem in a sophisticated web operation involves a wide range of
            both technical and business knowledge. For instance, in terms of
            designing “circuit breakers” that limit the impact of the failure
            of one component, Nygard notes that deciding what to do when a
            circuit breaker trips is not merely a technical decision, but
            involves a deep understanding of business processes: “Should a
            retail system accept an order if it can’t confirm availability of
            the customer’s items? What about if it can’t verify the customer’s
            credit card or shipping address?” (p.  97) Later in the book, a
            retail system went down entirely on Black Friday, costing his
            client about a million dollars an hour in sales. Fixing the problem
            involved understanding the functioning of the frontend of the
            online store, the order management system, and the scheduling
            system, and the interactions of the three.
            </p>
            
            <p>
            A software engineer who thinks of his job narrowly, as just
            being responsible for writing the code to do the task he is told the code
            should do, is not going to be thinking of the multiple other areas
            this change would affect. And a higher-level designer is unlikely
            to know enough of the details of all of these areas to fully
            understand the impact of this change: the best bet for being able
            to successfully respond to this changed business requirement is for
            the people working in each specialization also to have a vision of
            the overall system, an understanding of how other specialized areas
            function, and to have robust communication channels open between
            the various specialties: in other words, to break down the silo
            walls produced by a rigid division of labor, and embrace agile
            development principles. Or, as said in Disciplined Agile:
            </p>
            
            <blockquote>
                However, to succeed delivery teams must often work with people
                outside of the team, such as enterprise architects, operations
                engineers, governance people, data management people, and many
                others.  For agile/lean delivery teams to be effective these
                people must also work in an agile/lean manner. (<a
                href="http://www.disciplinedagiledelivery.com/agility-at-scale/disciplined-agile-2/">
                    Disciplined Agile</a>)
            </blockquote>

        </details>

        <details>
            <summary class="sum1">
                Lesson 4: Software Development as a Discovery Procedure
            </summary>

            <p>
                Nobel-Prize-winning economist F.A. Hayek was one of the most
                significant social theorists of the 20th century. 
                He did important work on the theory of the business cycle, on
                monetary theory, on the theory of capital, on the informational
                role of market prices, on the nature of complex phenomena, and on
                the importance of group selection in evolution.
            </p>
    
            <p>
                Hayek's work has important insights to
                offer those advancing Lean / Agile / DevOps ideas for IT.
                Here I will focus on his paper "Competition as a Discovery
                Procedure," and note how similar Hayek's vision for the role of
                competition in the market is to the Agile understanding of the
                importance of the "development" part of the phrase "software
                development."
            </p>
    
            <p>
                That essay of Hayek's was written in response to the model of
                "perfect competition" that had come to dominate economics in the
                middle of the 20th century. In that model, "competition" meant a
                state of affairs in which each market participant already knew every
                relevant detail about the market in which they participated, and
                thus simply "accepted" a price that, somehow, mysteriously emerged
                from the "given data" of their market. In such a situation no
                actual competition, as it is commonly understood, really occurs:
                every "competitor" already knows what product to offer, what price
                to charge, and simply passively accepts their situation as it
                stands.
            </p>
    
            <p>
                Similarly, the waterfall model of software development simply
                assumes that what has to be discovered, in the process of software
                <i>development</i>, is already fully known at the start of the
                process. Instead of correctly understanding development as a
                <i>process</i> through which the analysts, coders, testers,
                documenters, and users come to a mutual understanding of what the
                software should really be like, the waterfall model posits that
                certain experts can fully envision what the final product should
                be, right at the start of the process. "Software development" then
                consists of these experts drawing up a document analogous to one
                of the "five-year plans" of the Soviet Union, detailing
                how all of the other "participants" should work, according to the
                experts' plan. No further input is needed as far as what the
                software being "developed" should actually do. But in reality,
                as Eric Evans notes:
            </p>
                
            <blockquote>
                <i>When we set out to write software, we
                    never know enough.</i> Knowledge on the project is fragmented,
                scattered among many people and documents, and it's mixed with
                other information so that we don't even know which bits
                of knowledge we really need. Domains that seem less
                technically daunting can be deceiving: we don't realize
                how much we don't know. This ignorance leads us to make
                false assumptions. (Evans, p. 15)
            </blockquote>
    
            <p>
                Hayek, describing the dependence of economists on the perfect
                competition model, admits:
            </p>
    
            <blockquote>
                It is difficult to defend economists against the charge that for
                some 40 or 50 years they have been discussing competition on
                assumptions that, if they were true of the real world, would make
                it wholly uninteresting and useless. If anyone really knew all
                about what economic theory calls the <i>data</i>, competition would
                indeed be a very wasteful method of securing adjustment to these
                facts. (Hayek, 179)
            </blockquote>
    
            <p>
                He goes on to write:
            </p>
    
            <blockquote>
                In sports or in examinations, no less than in the world of
                government contracts or prizes for poetry, it would clearly be
                pointless to arrange for competition, if we were certain beforehand
                who would do best... I propose to consider competition as a
                procedure for the discovery of such facts as, without resort to it,
                would not be known to anyone... (Hayek, 179)
            </blockquote>
    
            <p>
                This, I suggest, is quite analogous to software development: it
                would be pointless to engage in such a time-consuming, mentally
                challenging activity if we knew in advance what software "would do
                best." We engage in software development to discover "such facts
                as, without resort to it, would not be known to anyone." It is only
                when we put our interface in front of real users that we find out
                if it really is "intuitive." It is only when we confront our
                theoretical calculations with the real data that we know if we got
                them right. It is only when we put our database out to meet real
                loads that we can tell if its performance is adequate. We can only
                tell if our CDN design meets our goals when it actually has to
                deliver content. None of this means that we should not plan <i>as
                much as possible</i>, in advance, to make sure our software is up
            to snuff, just that how much is possible is quite limited. 
            </p>
    
            <p>
                Hayek highlights the true value of competition in the following
                passage:
            </p>
    
            <blockquote>
                [C]ompetition is valuable only because, and so far as,
                its results are unpredictable and on the whole different from those
                which anyone has, or could have, deliberately aimed at...
                We do not know the facts we hope to discover means of competition,
                we can never ascertain how effective it has been discovering those
                facts that might be discovered...
                The peculiarity of competition -- which it has in common with
                scientific method -- is that its performance cannot be tested in
                particular instances where it is significant... The advantages of
                accepted scientific procedures can never be proveed scientifically,
                but only demonstrated by the common experience that, on the whole,
                they are better adapted to delivering the goods than alternative
                approaches. (Hayek, 180)
            </blockquote>
    
            <p>
                Bjarne Stroustrup, the creator of C++, has very similar things to
                say about programming:
            </p>
    
            <blockquote>
                When we start, we rarely know the problem well. We often think we
                do... but we don't. Only a combination of thinking about the
                problem (analysis) and experimentation (design and implementation)
                gives us the solid understanding that we need to write a good
                program... It is rare to find that we had anticipated everything
                when we analyzed the problem and made the initial design. We should
                take advantage of the feedback that writing code and testing give
                us (Stroustrup, 178).
            </blockquote>
    
            <p>
                Given that competition is a discovery procedure, and thus we
                can't ever predict, with certainty, the results of market
                competition, Hayek considers what sort of predictions economists
                can make, if any? After all, if economics is a science, we expect
                it to say at least something about the course of events. Hayek
                concludes that:
            </p>
    
            <blockquote>
                [The theory of the market's] capacity to predict is necessarily
                limited to predicting the kind of pattern, or the abstract
                character of the order that will form itself, but does not extend
                to the prediction of particular facts. (Hayek, 181)
            </blockquote>
    
            <p>
                Similarly, in software development, although we can't anticipate in
                advance exactly what lines of code will be needed... or development
                would be done!... we can anticipate that good software will exhibit
                certain patterns. And thus we see Hayek anticipating the "pattern
                language" approach to software development that was imported from
                the architectural works of Christopher Alexander into software
                development.
            </p>
    
            <p>
                Let us turn aside from contemplating the market order, upon
                which Hayek focuses most of his attention, and consider the
                other order Hayek mentions: science. Although any scientific
                enterprise involves planning, we cannot possibly plan out in
                advance what discoveries we will make in the course of some
                scientific research: if we knew <i>those</i>, we would have
                already discovered them, and our research would be done: we
                would just be writing up the results. But that is precisely
                what the waterfall model supposes: we already <i>know</i> what
                the software in question must do: development is complete, and
                all that remains is to turn the requirements into an executable
                program: essentially, just "writing up the results." This
                approach actually blocks the process of discovery, as it leaves
                no room for the developers or the users to achieve new
                realizations in the process of turning the blueprint into
                working code, realizations that would expose the "specs," the
                master plan, as being based upon false hypotheses.
            </p>
    
            <p>
                One aspect of recognizing an order as a discovery procedure is
                the implication that <i>where</i> in an organization the most
                relevant discoveries will be made is also not predictable in
                advance. Many scientific discoveries have been made because a
                lab assistant failed to follow some accepted procedure, or
                noticed something her "betters" had missed. And many successful
                market innovations arose at the level of the factory floor or
                the sales visit, and not in the executive suite.
            </p>
    
            <p>
                The waterfall model assumes that every insight about the
                proper form of the final software product will come from
                the "analysts," and that it is the job of "the workers,"
                such as programmers, to simply turn those insights into
                executable code. In this respect, the waterfall model has
                much in common with "Taylorism," the blueprint for mass
                production pioneered by Frederick Taylor around the turn
                of the last century. As Jerry Muller describes it:
            </p>
    
    
            <blockquote>
                Taylorism was based on trying to replace the implicit knowledge of
                the workmen with mass production methods developed, planned,
                monitored, and controlled by managers. 'Under scientific
                management,' [Taylor] wrote, 'the managers assume... the burden of
                gathering together all the traditional knowledge which in the past
                has been possessed by the workmen and then of classifying,
                tabulating, and reducing this knowledge to rules, laws, formulae...
                Thus all of the planning which under the old system was done by the
                workmen, must of necessity under the new system be done by
                management in accordance with the laws of science. (Muller,
                pp.32-33)
            </blockquote>
    
            <p>
                But Taylorism and similar top-down approaches proved inadequate in
                manufacturing, as demonstrated by the triumph of the Toyota
                Production System, just as top-down planning failed in the Soviet
                Union, and just as it does in science. Perhaps ther most important
                piece of wisdom contained in the Lean / Agile / DevOps movement is
                that the waterfall model of software development fails for very
                similar reasons.
            </p>
    
    
            <p>
                Once we recognize software development is a discovery procedure,
                it should prove useful to categorize some of the features of a
                program that are most likely to be discovered in the actual process
                of development, rather than having been perfectly anticipated in
                our initial analysis of our users' requirements. What I offer here
                is only intended as an initial cut at what surely is a much more
                extensive list that could be developed. With that caveat in mind,
                in the process of actually developing software, here are some
                likely areas where our initial analysis will fall short of the
                mark:
            </p>
    
            <ul class="nested">
                <li>
                    We will discover "corner solutions" we had not anticipated.
                    Corner solutions are extreme cases that are not easy to detect
                    in the analysis phase, such as a buyer who has purchased every
                    single product the company sells (what do we market to her?),
                    or a security the price of which has dropped to zero (were we
                    dividing by that price at some point?).
                </li>
                <li>
                    Some aspect of the user interface that was "obvious" to the
                    designers will appear completely obscure to the actual users:
                    we won't know this until we put some working software in front
                    of them.
                </li>
                <li>
                    A calculation or algorithm that the users thought was adequate
                    to their purposes actually is not: it may have handled a few
                    common cases correctly, but once exposed to real world data,
                    its shortcomings may become obvious.
                </li>
                <li>
                    Some part of the system may incur a load that was not
                    anticipated during the analysis phase: a particular feature may
                    be much more popular than was predicted, and the capacity of
                    the components assigned to handle that feature might be
                    swamped.
                </li>
                <li>
                    There may be regulatory/legal requirements for the software
                    that the users interviewed by the analysts simply took for
                    granted, the violation of which will only become apparent when
                    those users are faced with a working version of the software.
                </li>
                <li>
                    "Black swan" events will arise in the course of development: a
                    market crash, a new, unforeseen law, a brand-new market
                    emerging, a natural disaster, or a security threat. When we
                    delay as many decisions to as late a time as possible, rather
                    than trying to make all siginificant choices up front in an
                    "analysis phase," we are far more flexible in responding to
                    such events. As Nassim Taleb wrote, "once we produce a theory,
                    we are not likely to change our minds -- so those who delay
                    developing their theories are better off" (Taleb, 144).
                </li>
            </ul>
    
            <h4>
                Bibliography
            </h4>
    
            <p>
                <i>Domain-Driver Design: Tackling Complexity in the Heart of
                    Software</i>,
                Eric Evans,
                Addison-Wesley,
                Upper Saddle River (New Jersey),
                2004.
            </p>
    
            <p>
                "Competition as a Discovery Procedure," in
                <i>New Studies in Philosophy, Politics, Economics
                    and the History of Ideas</i>,
                F.A. Hayek,
                University of Chicago Press,
                Chicago,
                1978.
            </p>
    
            <p>
                <i>Programming: Principles and Practice Using C++</i>,
                Bjarne Stroustrup,
                Addison-Wesley,
                Upper Saddle River (New Jersey),
                2014.
            </p>
    
            <p>
                <i>The Tyranny of Metrics</i>,
                Jerry Z. Muller,
                Princeton University Press,
                Princeton,
                2018.
            </p>
    
            <p>
                <i>The Black Swan</i>,
                Nassim Nicholas Taleb,
                Random House,
                New York,
                2010.
            </p>
        </details>

        <details>
            <summary class="sum1">
                Other Readings
            </summary>

            <ul class="nested">
               <li>
                    <a href="https://leankit.com/learn/lean/principles-of-lean-development/">
                        Lean development principles
                    </a>
                </li>

                <li>
                    <a href="https://www.agilealliance.org/agile101/12-principles-behind-the-agile-manifesto/">
                        Agile development principles
                    </a>
                </li>

                <li>
                    <a href="https://hackerchick.com/just-do-it-quick-intro-to-agiles/">
                        Agile Technical Practices
                    </a>
                </li>

                <li>
                    <a href="https://gcallah.github.io/TechManagement/SDAsDiscovery.html">
                        Software Development as a Discovery Procedure
                    </a>
                </li>

            </ul>

            <p>
                Although the Agile principles are great, some people have
                questioned how it is being applied, especially when it
                comes to the "Scrums" that so often characterize Agile
                practice. Here are some critics of Scrums:
            </p>

            <ul class="nested">
                <li>
                    <a href="https://michaelochurch.wordpress.com/2015/06/06/why-agile-and-especially-scrum-are-terrible/">
                        Why "Agile" and especially Scrum are terrible
                    </a>
                </li>

                <li>
                    <a href="http://okigiveup.net/not-big-fan-of-scrum/">
                        Why I'm not a big fan of Scrum
                    </a>
                </li>
            </ul>

        </details>


        {% include 'quiz.html' %}

{% endblock content %}
