{% extends "base.html" %}
{% block content %}
<div class="module">
        <h1>
            Infrastructure as Code
        </h1>

        <figure>
            <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/Evacuated_Highway_401_Color.jpg/580px-Evacuated_Highway_401_Color.jpg"
            width="21%">
            <figcaption>
            </figcaption>
        </figure>

        <p class="leadquote">
        </p>

        <details>
            <summary class="sum1">
                Lesson 1: What Is Infrastructure as Code?
            </summary>

            <figure>
                <iframe width="560" height="315"
                    src="https://www.youtube.com/embed/RO7VcUAsf-I"
                    frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>
                </iframe>
                <figcaption>
                    Infrastructure as code: What is it? Why is it important?
                    <br />
                    (This is a fantastic <b>3 minute</b> explanation of the
                    value of Infrastructure as Code.)
                </figcaption>
            </figure>

            <p>
                Infrastructure as code (IaC) as the idea that, rather than manually
                provisioning servers, or setting up hardware through a
                point-and-click GUI, the "server room" should itself be managed 
                by code. That code can then be put under version control,
                tested, deployed with automated build tools, and so on.
                The code also serves as necessarily up-to-date documentation of 
                what the infrastructure is.
            </p>

            <p>
                The advantages of IaC can be divided into three main
                categories:
            </p>

            <ul class="nested">
                <li>
                    <span class="hilight">Cost savings</span>:
                    By automating hardware provisioning, the time of the people
                    who would have been doing that by hand is freed up for
                    other tasks.
                </li>

                <li>
                    <span class="hilight">Speed of deployment</span>:
                    It is much faster to configure infrastructure
                    by running a script than by manually setting a bunch
                    of parameters in a GUI interface.
                </li>

                <li>
                    <span class="hilight">Lower error rates</span>:
                    It is error-prone, because it is boring, too configure
                    systems "by hand." A script can be debugged once, and
                    then will run reliably again and again.
                    Furthermore, as code, the infrastructure can be read and 
                    reasoned about. It is very hard to do that with a bunch of
                    checkboxes!
                </li>
            </ul>

            <p>
                (Source:
                <a href="https://en.wikipedia.org/wiki/Infrastructure_as_Code">
                    Wikipedia on Infrastructure as Code
                </a>
                )
            </p>

            <p>
                <span class="hilight">A DevOps principle</span>:
                Asking people to <i>behave like automatons</i> 
                bores and dehumanizes
                them. Asking them to devise clever ways
                <i>to automate things</i>
                interests them, and treats them as the rational 
                beings that they are!
            </p>

        </details>

        <details>
            <summary class="sum1">
                Lesson 2: Available Tools
            </summary>

            <details>
                <summary class="sum2">
                    Puppet
                </summary>
                    <h5>Pros:</h5>
                    <ul class="nested">
                        <li>
                            Easy installation
                        </li>
                        <li>
                            Supports all majors operating systems
                        </li>
                        <li>
                            GUI is user friendly
                        </li>
                        <li>
                            Stable and mature solution
                        </li>
                    </ul>

                    <h5>Cons:</h5>
                    <ul class="nested">
                        <li>
                            New users must learn Puppet DSL (domain-specific
                            language)
                        </li>
                        <li>
                            Remote execution is challenging
                        </li>
                    </ul>

                    <p>
                    <a href="https://gcallah.github.io/DevOps/deployment/puppet.html"> More on puppet </a>
                    </p>

            </details>

            <details>
                <summary class="sum2">
                  Chef
                </summary>
                <h5>Pros:</h5>
                <ul class="nested">
                    <li>
                        Meant to be used by programmers
                    </li>
                    <li>
                        Useful for large-scale development
                    </li>
                    <li>
                        Stable and mature solution
                    </li>
                    <li>
                        Good version control capabilities
                    </li>
                </ul>
                <h5>Cons:</h5>
                <ul class="nested">
                    <li>
                        Complicated tool to use
                    </li>
                    <li>
                        Familiarity with Ruby is required
                    </li>
                    <li>
                        Documentation can be overwhelming
                    </li>
                </ul>
                <p>
                <a href="https://gcallah.github.io/DevOps/deployment/chef.html"> More on Chef </a>
                </p>
            </details>
            <details>
                <summary class="sum2">
                  Ansible
                </summary>
                <h5>Pros:</h5>
                <ul class="nested">
                    <li>
                        Easy and fast deployment
                    </li>
                    <li>
                        Secure SSH connection
                    </li>
                    <li>
                        Meant for environments that can scale rapidly
                    </li>
                    <li>
                        Push and pull models are supported
                    </li>
                </ul>
                <h5>Cons:</h5>
                <ul class="nested">
                    <li>
                        Basic support for Windows
                    </li>
                    <li>
                        GUI is not very interactive
                    </li>
                    <li>
                        Difficult to locate syntax errors with YAML
                    </li>
                </ul>
                <p>
                <a href="https://gcallah.github.io/DevOps/deployment/ansible.html"> More on Ansible </a>
                </p>
            </details>
            <details>
                <summary class="sum2">
                  SaltStack
               </summary>
                <h5>Pros:</h5>
                <ul class="nested">
                    <li>
                        Implemented in Python and controlled with YAML files
                    which are simple to understand
                    </li>
                    <li>
                        Fast communication between master and client
                    </li>
                    <li>
                        Provides high scalability and resiliency
                    </li>
                    <li>
                        Vibrant support community
                    </li>
                </ul>
                <h5>Cons:</h5>
                <ul class="nested">
                    <li>
                        Difficult to set up
                    </li>
                    <li>
                        Salt GUI is under development
                    </li>
                    <li>
                        Does not support a variety of Operating Systems
                    </li>
                </ul>
            </details>

        </details>

        <details>
            <summary class="sum1">
                Lesson 3: Running Docker
            </summary>

                <p class="author">
                    by
                    <br />
                    Prashantkumar Patel and Prof. Callahan
                </p>


                <p>
                    <span class="hilight">First thing</span>:
                    Make sure you have Docker installed! The rest
                    of the demo will be inapplicable if you do not.
                </p>

                <p>
                    <span class="hilight">Secondly</span>:
                    Please clone (if you have not already) our online DevOps
                    repo:
                    <br />
                    <code>
                        git clone https://github.com/gcallah/OnlineDevops.git
                    </code>
                </p>

                <p>
                    Once you have cloned that repo, please open two shells: in
                    one, we will look at your local environment, and in the
                    other we will explore the container.
                </p>

                <p>
                    In one of the two shells, in your OnlineDevops directory,
                    please run:
                    <br />
                    <code>
                        ./devops_container.sh
                    </code>
                    <br />
                    That should put you inside the OnlineDevops container: if
                    that command worked, you should see your prompt change.
                    <br />
                    If it did, let's explore the shells you are in a little to
                    try to understand better what a container is.
                    <br />
                    I am going to proceed by showing you the results of running
                    the same command inside and outside the container on my
                    machine: your results will be different, but similar, to
                    mine.
                </p>

                <p>
                    First of all, let's look at the root file system, inside
                    and outside the container:
                </p>

                <p>
                    Outside the container:
                    <br />
                    <code>ls / </code>
                    <br />
                    <pre>
    Macintosh:OnlineDevops gcallah$ ls /
    Applications			bin				net
    Library				cores				opt
    Network				debug.txt			private
    Shockwave Log			debug.txt.1			sbin
    System				dev				tmp
    User Guides And Information	etc				usr
    User Information		home				var
    Users				installer.failurerequests
    Volumes				logFile.xsl
                    </pre>
                    
                </p>

                <p>
                    Inside the container:
                    <br />
                    <code>ls / </code>
                    <br />
                    <pre>
    root@a5dd222a9812:/home/DevOps# ls /
    bin   dev  home  lib64	mnt  proc	       root  sbin  sys	usr
    boot  etc  lib	 media	opt  requirements.txt  run   srv   tmp	var
                    </pre>
                </p>

                <p>
                    What's of note here: From outside and from inside the
                    container, we see completely different file systems!
                    <br />
                    What about our view of what processes are running?
                </p>

                <p>
                    Outside the container:
                    <br />
                    <code>ps -ef | wc -l</code>
                    <br />
                    <pre>
     Macintosh:OnlineDevops gcallah$ ps -ef | wc -l
     667
                    </pre>
                </p>

                <p>
                   From outside the container, the OS lists 667 processes
                   as running on my Mac. 
                </p>


                <p>
                    Inside the container:
                    <br />
                    <code>ps -ef</code>
                    <br />
                    <pre>
    root@a5dd222a9812:/home/DevOps# ps -ef
    UID        PID  PPID  C STIME TTY          TIME CMD
    root         1     0  0 Oct25 pts/0    00:00:00 bash
    root       192     1  0 21:18 pts/0    00:00:00 ps -ef
                    </pre>
                </p>

                <p>
                   From inside the container, there are two processes running! 
                </p>

                <h4>
                    Some Docker commands
                </h4>

                <p>
                    Now let's look at what some Docker commands are available,
                    and what they do.
                </p>

                <p>
                    <code>docker ps</code>
                </p>

                <p>
                    This will list your currently running Docker images. When 
                    Prof. Callahan runs it while preparing this lecture, he
                    sees:
                    <br />
                    <pre>
    Macintosh:OnlineDevops gcallah$ docker ps
    CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES
    429ff1a37d21        devops              "bash"              11 seconds ago
    Up 6 seconds        0.0.0.0:32768-&gt;8000/tcp   stupefied_swanson
                    </pre>
                </p>

                <p>
                   <code>docker images</code>
                </p>

                <p>
                    This command should give you the list of images
                    that are available on the system. For example
                    in Prashant's system it looks something like
                    this:
                <br />
                    <pre>
    ENG-EJC369-02:$ docker images
    REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE
    gcallah/jenkins_py3   latest              21130e104ca1        4 weeks ago         742MB
    jenkins               latest              cd14cecfdb3a        6 weeks ago         696MB
    gcallah/indra         v7                  ad9670e8b27f        2 months ago        946MB
    python                latest              efb6baa1169f        5 months ago        691MB
    ubuntu                latest              f975c5035748        5 months ago        112MB
    gcallah/emu86         v4                  f6833ae8bf9e        6 months ago        776MB
    gcallah/django        latest              432de70e222d        6 months ago        769MB
    bash                  latest              59507b30b48a        6 months ago        12.2MB
    alpine                latest              3fd9065eaf02        7 months ago        4.15MB
                    </pre>
                </p>

                <p>
                    In the above listing, the <code>nginx</code> image
                    is not installed. Running the following command will
                    install the nginx imagee.
                </p>

                <p>
                <code>
                    docker pull nginx
                </code>
                </p>
                <p>
                    Now that you have installed the nginx image,
                    just run the docker images command again,
                    in the list you should see ngnix image as below:
                <br />
                    <pre>
    ENG-EJC369-02:$ docker images
    REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE
    nginx                 latest              71c43202b8ac        7 hours ago         109MB
    gcallah/jenkins_py3   latest              21130e104ca1        4 weeks ago         742MB
    jenkins               latest              cd14cecfdb3a        6 weeks ago         696MB
    gcallah/indra         v7                  ad9670e8b27f        2 months ago        946MB
    python                latest              efb6baa1169f        5 months ago        691MB
    ubuntu                latest              f975c5035748        5 months ago        112MB
    gcallah/emu86         v4                  f6833ae8bf9e        6 months ago        776MB
    gcallah/django        latest              432de70e222d        6 months ago        769MB
    bash                  latest              59507b30b48a        6 months ago        12.2MB
    alpine                latest              3fd9065eaf02        7 months ago        4.15MB
                    </pre>
                </p>

                <h4>
                    Download website code
                </h4>

                <p>
                    Ok now that you have download the nginx image,
                    let's download the static website that you
                    are going to host inside the docker container.
                    We are going to use the algorithms website for
                    professor's other subject. You can find the
                    code for the website 
                    <a href="http://gitub.com/gcallah/algorithms.git">
                    here.
                    </a>
                </p>

                <p>
                    Please remember the location where you have
                    cloned the repository. I have cloned it in
                    <code> /Users/prashant/school/algorithms</code>
                    you's will be different than this, please note
                    the location. Below is the screenshot of algorithms
                    directory.
                </p>

                <h4>
                    Let's make a container
                </h4>

                <p>
                    Ok, so we have downloaded the nginx image and
                    the code of the website which we want to host
                    All we need to do is just make a container
                    out of the image. We will put the code of
                    website inside the container so that the
                    webserver which is nginx in our case can
                    read the html files and host it in local
                    server.
                    The command for that is as shown below.
                </p>
                <p>
                    <code>
                        docker run --name algo_website -p 127.0.0.1:8080:80
                        -v /Users/prashant/school/algorithms/:/usr/share/nginx/html
                        -d nginx
                    </code>
                </p>

                <p>
                    Please don't forget to change the location of
                     algorithms directory in above command.
                     After you run the command open the browser
                     and type <code>http://localhost:8080</code>
                     and you should be able to see the webpage.
                     Windows user should use the address
                     <code>http://192.168.99.100:8080</code>
                     instead of localhost.
                </p>

        </details>

        <details>
            <summary class="sum1">
                Our Docker Implementation
            </summary>

            <p>
                We use Docker in our projects for two main reasons:
            </p>

            <ol class="nested">
                <li>
                    To set up a local version of a web server that will be
                    configured "just like" our production server. ("Just like"
                    is in quotes because that is always the ideal, but it may
                    not be fully achieved.)
                </li>
                <li>
                    To provide our full suite of development tools, such as the
                    correct Python version, make, flake8, various Python
                    libraries, etc., in one simple to build package, so all
                    developer's have a consistent environment.
                </li>
            </ol>

            <p>
            So we need to know how to create the right container for 
            each project. 
            Each project we work on should have a 
            <code>Dockerfile</code> consisting of instructions
            on how to build the image for that project, a
            <code>requirements.txt</code> listing what
            external modules need to be included in the image,
            and a line in the project's <code>makefile</code>
            automating the build of the image.
            This is <i>infrastrcuture as code</i>, since the infrastructure for 
            the project is built from these files of code.
            </p>

            <p>
                So, in the <code>makefile</code> we want something 
                like:
            </p>

            <p>
            <code>
        container: $(DOCKER_DIR)/Dockerfile  $(DOCKER_DIR)/requirements.txt
        <br />
            &nbsp; &nbsp; &nbsp; &nbsp; docker build -t indra docker
            </code>
            </p>

            <ul class="nested">
                <li>
                    <a href="https://github.com/gcallah/indras_net/blob/master/docker/Dockerfile">
                        Here is a sample Dockerfile.
                    </a>
                    <br />
                    The <code>FROM python:3.6.0</code> 
                    command says what base image to build
                    our image from.
                    <br />
                    The <code>COPY requirements.txt /requirements.txt</code>
                    line brings the requirements file inside the container.
                    <br />
                    The line
                    <code>RUN pip install -r requirements.txt</code> 
                    installs everything from the requirements file in the
                    container.
                    <br />
                    The line
                    <code>ENV user_type TERMINAL</code> 
                    sets an environment variable (<code>user_type</code>)
                    that will be available inside the container.
                    <br />
                    <code>WORKDIR /home/IndrasNet/</code>
                    sets the starting directory inside the container.
                </li>

                <li>
                    <a href="https://github.com/gcallah/indras_net/blob/master/docker/requirements.txt">
                        Here is the requirements file it uses.
                    </a>
                </li>
            </ul>


        </details>

        <details>
            <summary class="sum1">
                Other Readings
            </summary>

            <ul class="nested">
               <li>
                    <a href="https://puppet.com/blog/containers-are-eating-world">
                        Containers are eating the world
                    </a>
                </li>

                <li>
                    <a href="https://www.ibm.com/developerworks/java/library/a-devops2/index.html">
                        Infrastructure automation
                    </a>
                </li>

                <li>
                    <a href="https://www.ibm.com/developerworks/library/d-bbd-guide-iac/">
                        A Behavior Driven Developer's guide to Infrastructure as Code
                    </a>
                </li>

            </ul>

        </details>


        {% include 'quiz.html' %}

{% endblock content %}
